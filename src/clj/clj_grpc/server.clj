(ns clj-grpc.server
  (:require [clojure.core]
            [camel-snake-kebab.core :as csk]
            [com.stuartsierra.component :as component]
            [clojure.spec.alpha :as spec])
  (:import [io.grpc ServerBuilder]))

(defonce grpc-java-bindings-per-ns (atom {}))
(defonce grpc-services (atom []))

(spec/def ::port int?)

(spec/def ::namespace-path string?)
(spec/def ::service-name (spec/or :symbol symbol? :string string?))
(spec/def ::service (spec/tuple ::namespace-path ::service-name))
(spec/def ::services (spec/coll-of ::service))

(spec/def ::type string?)

(spec/def ::java-package string?)
(spec/def ::java-outer-classname string?)

(spec/def ::rpc-function-name symbol?)
(spec/def ::message-key keyword?)
(spec/def ::message-value any?)
(spec/def ::data (spec/map-of ::message-key ::message-value))

(defn- generate-class-name
  "Generate name of Java class implementing service of name `SERVICE-NAME` from within Clojure namespace `NS`"
  [ns-name service-name]
  (str (csk/->snake_case ns-name) "." service-name "ServiceImpl"))

(defmacro implement-grpc-service
  "Implement gRPC service `SERVICE` in current namespace, importing all necessary Java classes and preparing
  environment. By providing necessary details in form `JAVA-PACKAGE` and `JAVA-OUTER-CLASS-NAME` (which are defined in
  `.proto` file), it will hopefully guess naming of Java classes automatically."
  [service-name & {:keys [java-package java-outer-classname]}]
  {:pre [(spec/valid? ::service-name service-name)
         (spec/valid? ::java-package java-package)
         (spec/valid? ::java-outer-classname java-outer-classname)]}
  (let [gen-class-name (symbol (generate-class-name (ns-name *ns*) service-name))
        extended-class-name (symbol (str java-package "." service-name "Grpc$" service-name "ImplBase"))]
    `(do
       (swap! grpc-java-bindings-per-ns assoc-in [(ns-name *ns*) :java-package] ~java-package)
       (swap! grpc-java-bindings-per-ns assoc-in [(ns-name *ns*) :java-outer-classname] ~java-outer-classname)
       (clojure.core/import* "io.grpc.stub.StreamObserver")
       (gen-class :name ~gen-class-name
                  ;; extends class autogenerated by `lein protoc && lein javac` from proto file
                  :extends ~extended-class-name))))

(defmacro get-grpc-java-binding-property [property]
  `(get-in @clj-grpc.server/grpc-java-bindings-per-ns [(ns-name *ns*) ~property]))

(defmacro on-next
  "Call gRPC `onNext` callback, replying on StreamObserver `RES` with message of type `TYPE` initielized with kebab-cased
  key-value map `DATA`.

  Example call:
    (on-next \"MessageType\" res
      {:name                  \"Name\"
       :description           \"Description\"})))
  "
  [type res data]
  {:pre [(spec/valid? ::type type)
         (spec/valid? ::data data)]}
  (let [builder (gensym "builder")
        class-to-load (str (get-grpc-java-binding-property :java-package) "." (get-grpc-java-binding-property :java-outer-classname) "$" type)
        builder-class (symbol (str class-to-load "/newBuilder"))]
    `(do
       ;; import response type class
       (clojure.core/import* ~class-to-load)
       (.onNext ~res
                (let [~builder (~builder-class)]
                  ~@(map (fn [[key value]]
                           (let [setter (symbol (csk/->camelCase (str ".set-" (name key))))]
                             `(~setter ~builder ~value)))
                         data)
                  (.build ~builder))))))

(defmacro defrpc
  "Implement new RPC function `RPC-NAME` returning type `TYPE` within service being implemented in current namespace. Use `ON-NEXT` function in `BODY` to reply."
  [rpc-function-name [this req res] & body]
  {:pre [(spec/valid? ::rpc-function-name rpc-function-name)]}
  (let [fn-name (symbol (str "-" rpc-function-name))
        req* (gensym)]
    `(do
       ;; define handler function
       (defn ~fn-name [~this ~req* ~res]
         (let [~req (bean ~req*)]
           (do ~@body))
         (.onCompleted ~res)))))


;; Component for https://github.com/danielsz/system
;;

(defn- build-grpc-component [component server]
  (if (instance? io.grpc.netty.NettyServerBuilder server)
    (update component :server #(.build %))
    component))

(defn- start-grpc-component [component]
  (if (instance? io.grpc.internal.ServerImpl (:server component))
    (update component :server #(.start %))
    component))

(defn- stop-grpc-component [component]
  (let [server (:server component)]
    (when (instance? io.grpc.internal.ServerImpl server)
      (.shutdown server))
    (assoc component :server nil)))

(defrecord GrpcServer [server]
  component/Lifecycle
  (start [component]
    (-> (build-grpc-component component server)
        (start-grpc-component)))
  (stop [component]
    (stop-grpc-component component)))


(defmacro make-grpc-server
  "Macro for creating new gRPC server componenet.`SERVICES` is sequence of vectors `[ns-name service-name]`"
  [port services]
  {:pre [(spec/valid? ::port port)]}
  (let [server (gensym "server")]
    `(do
       (clojure.core/import* "io.grpc.ServerBuilder")
       (let [~server (ServerBuilder/forPort ~port)]
         ~@(map (fn [[ns service-name]]
                  `(do
                     (clojure.core/import* ~(generate-class-name ns service-name))
                     (.addService ~server (new ~(symbol (generate-class-name ns service-name))))
                     ))
                services)
         (-> (Runtime/getRuntime)
             (.addShutdownHook
               (Thread. (fn []
                          (if (not (nil? ~server))
                            (.shutdown ~server))))))
         ~server))))

(defmacro new-grpc-server [& {:keys [port services] :or {port 5000 services []}}]
  "Create new GRPC server listening on port `PORT`. `SERVICES` is sequence of vectors `[NS-NAME SERVICE-NAME]` where
  `NS-NAME` is name of namespace (string) where service `SERVICE-NAME` is implemented (with `IMPLEMENT-GRPC-SERVICE`)."
  `(map->GrpcServer {:server (make-grpc-server ~port ~services)}))
