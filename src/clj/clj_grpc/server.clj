(ns clj-grpc.server
  (:require [clojure.core]
            [camel-snake-kebab.core :as csk]
            [com.stuartsierra.component :as component]
            [clojure.spec.alpha :as spec]
            [clojure.walk :as walk])
  (:import [io.grpc ServerBuilder]))

(defonce grpc-java-bindings-per-ns (atom {}))
(defonce grpc-services (atom []))

(spec/def ::port int?)

(spec/def ::namespace-path string?)
(spec/def ::service-name (spec/or :symbol symbol? :string string?))
(spec/def ::service (spec/tuple ::namespace-path ::service-name))
(spec/def ::services (spec/coll-of ::service))

(spec/def ::type string?)

(spec/def ::java-package string?)
(spec/def ::java-outer-classname string?)

(spec/def ::rpc-function-name symbol?)
(spec/def ::message-key keyword?)
(spec/def ::message-value any?)
(spec/def ::data (spec/map-of ::message-key ::message-value))

;; Utils

(defn- generate-class-name
  "Generate name of Java class implementing service of name `SERVICE-NAME` from within Clojure namespace `NS`"
  [ns-name service-name]
  (str (csk/->snake_case ns-name) "." service-name "ServiceImpl"))

;; h/t https://stackoverflow.com/a/9172515
(defn- construct [class & args]
  (clojure.lang.Reflector/invokeConstructor class (into-array Object args)))

(defn kebab-case-keys
  "Recursively transforms all map keys from camelCase keywords to kebabCase keywords."
  [m]
  (let [f (fn [[k v]] (if (keyword? k) [(csk/->kebab-case k) v] [k v]))]
    ;; only apply to maps
    (walk/prewalk (fn [x] (if (map? x)
                             (into {} (map f x)) x)) m)))

;; Implementation

(defmacro implement-grpc-service
  "Implement gRPC service `SERVICE` in current namespace, importing all necessary Java classes and preparing
  environment. By providing necessary details in form `JAVA-PACKAGE` and `JAVA-OUTER-CLASS-NAME` (which are defined in
  `.proto` file), it will hopefully guess naming of Java classes automatically."
  [service-name & {:keys [java-package java-outer-classname]}]
  {:pre [(spec/valid? ::service-name service-name)
         (spec/valid? ::java-package java-package)
         (spec/valid? ::java-outer-classname java-outer-classname)]}
  (let [gen-class-name (generate-class-name (ns-name *ns*) service-name)
        extended-class-name (symbol (str java-package "." service-name "Grpc$" service-name "ImplBase"))]
    `(do
       (swap! grpc-java-bindings-per-ns assoc-in [(ns-name *ns*) :java-package] ~java-package)
       (swap! grpc-java-bindings-per-ns assoc-in [(ns-name *ns*) :java-outer-classname] ~java-outer-classname)
       (swap! grpc-services (comp dedupe conj) ~gen-class-name)
       (clojure.core/import* "io.grpc.stub.StreamObserver")
       (gen-class :name ~(symbol gen-class-name)
                  ;; extends class autogenerated by `lein protoc && lein javac` from proto file
                  :extends ~extended-class-name))))

(defmacro get-grpc-java-binding-property [property]
  `(get-in @clj-grpc.server/grpc-java-bindings-per-ns [(ns-name *ns*) ~property]))

(defmacro on-next
  "Call gRPC `onNext` callback, replying on StreamObserver `RES` with message of type `TYPE` initielized with kebab-cased
  key-value map `DATA`.

  Example call:
    (on-next \"MessageType\" res
      {:name                  \"Name\"
       :description           \"Description\"})))
  "
  [type res data]
  {:pre [(spec/valid? ::type type)
         (spec/valid? ::data data)]}
  (let [builder (gensym "builder")
        class-to-load (str (get-grpc-java-binding-property :java-package) "." (get-grpc-java-binding-property :java-outer-classname) "$" type)
        builder-class (symbol (str class-to-load "/newBuilder"))]
    `(do
       ;; import response type class
       (clojure.core/import* ~class-to-load)
       (.onNext ~res
                (let [~builder (~builder-class)]
                  ~@(map (fn [[key value]]
                           (let [setter (symbol (csk/->camelCase (str ".set-" (name key))))]
                             `(~setter ~builder ~value)))
                         data)
                  (.build ~builder))))))

(defmacro defrpc
  "Implement new RPC function `RPC-NAME` returning type `TYPE` within service being implemented in current namespace. Use `ON-NEXT` function in `BODY` to reply."
  [rpc-function-name [this req res] & body]
  {:pre [(spec/valid? ::rpc-function-name rpc-function-name)]}
  (let [fn-name (symbol (str "-" rpc-function-name))
        req* (gensym)]
    `(do
       ;; define handler function
       (defn ~fn-name [~this ~req* ~res]
         (let [~req (kebab-case-keys (bean ~req*))]
           (do ~@body))
         (.onCompleted ~res)))))


;; Component for https://github.com/danielsz/system
;;

(defn- build-grpc-component [component server]
  (if (instance? io.grpc.netty.NettyServerBuilder server)
    (update component :server #(.build %))
    component))

(defn- start-grpc-component [component]
  (if (instance? io.grpc.internal.ServerImpl (:server component))
    (update component :server #(.start %))
    component))

(defn- stop-grpc-component [component]
  (let [server (:server component)]
    (when (instance? io.grpc.internal.ServerImpl server)
      (.shutdown server))
    (assoc component :server nil)))

(defrecord GrpcServer [server]
  component/Lifecycle
  (start [component]
    (-> (build-grpc-component component server)
        (start-grpc-component)))
  (stop [component]
    (stop-grpc-component component)))

(defn make-grpc-server
  "Create new gRPC server listening on port `PORT`"
  [port]
  (import [io.grpc ServerBuilder])
  (let [server (ServerBuilder/forPort port)]
    (doall (map (fn [service-class]
                  (.addService server (construct (Class/forName service-class))))
                @grpc-services))
    (-> (Runtime/getRuntime)
        (.addShutdownHook
          (Thread. (fn []
                     (if (not (nil? server))
                       (.shutdown server))))))
    server))

(defn new-grpc-server [& {:keys [port] :or {port 5000}}]
  "Create new GRPC server listening on port `PORT`."
  (map->GrpcServer {:server (make-grpc-server port)}))

;; For non-system setups
;;
(defn start-grpc [server]
  "Start gRPC server made with `MAKE-GRPC-SERVER"
  (.start (.build server)))

(defn stop-grpc [server]
  "Stop gRPC server made with `MAKE-GRPC-SERVER"
  (.shutdown (.build server)))
